:guid: %guid%
:user: %user%
:markup-in-source: verbatim,attributes,quotes

== Overview

In this workshop you will... to be completed by the workshop developer.
The following content is an example of what to include in an overview.

=== Lab Access

You can access your lab environment as {user} with password "{ssh_password}" with the following command:

[source,bash,options="nowrap",subs="{markup-in-source}"]
----
%ssh_command%
----

Your lab GUID is "{guid}".

An example var was set to %example_var%.

=== Workshop Information

Informational messages generated for your workshop:

[source,bash,options="nowrap"]
----
%user_info_messages%
----
'''

slug: step1
id: 7yxqmka1ckum
type: challenge
title: Downloading the Universal Base Image
notes:

* type: text
contents: |+
  # Goal:
  After completing this scenario, users will be able to install additional
  software into a container image.
+
# Concepts included in this scenario:

 ** Downloading a Red Hat Universal Base Image (UBI)
 ** Positioning or configuring a container to use 3rd party repositories
 ** Install 3rd party software into the container image
 ** Commit changes to create a new container image
 ** Validate the containerized application

+
# Example Usecase:
  You have a piece of software that you would like to deploy within a container
  image rather than installing it natively on the host system.  By using a
  container image, you can copy the entire environment for the software to
  several different hosts or run multiple copies of it on the same system.

tabs:

* title: Terminal
type: terminal
hostname: rhel
* title: RHEL Web Console
type: service
hostname: rhel
path: /
port: 9090
difficulty: basic
timelimit: 3660
--
The Red Hat Universal Base Image (UBI) is produced by Red Hat and is an easy
place to start when containerizing applications.  If you want to read more
about the UBI program, or the three different flavors of UBI, check out the
https://developers.redhat.com/articles/ubi-faq[FAQ - Universal Base Images]
for additional details.

In this lab, you will be installing additional software into the container
image, however that software runs as an interactive application.  So you will
need `yum`, but do not need `systemd` for managing services within the
container environment.  For that reason, you will be using the *Standard*
UBI image (as opposed to the Minimal or Multi-service images).

By executing the command below, your system will download the Standard UBI
image from Red Hat's registry.

[,bash]
----
buildah from registry.access.redhat.com/ubi9/ubi
----

[,]
....

Getting image source signatures
Checking if image destination supports signatures
Copying blob 2c9b1d3d1a0a done
Copying blob f95ee31bf3b7 done
Copying config 46720ac964 done
Writing manifest to image destination
Storing signatures
ubi-working-container
....

From the output above, you can see that the image was successfully downloaded
and a working container image was created and attached to the system with the
name of *ubi-working-container*.  You will use this working container in the
next steps to install additional software packages into the image.
= Positioning yum Repository
:difficulty: basic
:id: xz5d9zx17xlq
:slug: step2
:tabs: [{"title"=>"Terminal", "type"=>"terminal", "hostname"=>"rhel"}, {"title"=>"RHEL Web Console", "type"=>"service", "hostname"=>"rhel", "path"=>"/", "port"=>9090}]
:timelimit: 60
:type: challenge

In this lab, you are going to containerize a software package that is already
packaged in RPM format and stored in the Extra Packages for Enterprise Linux
(EPEL) repository.

Software often has requirements for prerequisite software that must be installed
on the machine in order for it to work properly.  `yum` will resolve those
dependencies for you, as long as it is able to locate the required packages in
repositories defined on the machine.  The Red Hat Universal Base Image (UBI)
downloaded in the previous step has access to some Red Hat Enterprise Linux
repositories.  However, the target package for the lab is from EPEL.  In
this step you will install the EPEL repository inside the container working
image.

In the command below, `buildah` is going to run a command on the
`ubi-working-container` image.  The `--` indicates that the command should be
executed from within the container, which means the results will be applied into
the container image.  Lastly, you are providing the `yum` command to install a
package that defines all of the repositories from EPEL, `epel-release-latest-9`.

[,bash]
----
buildah run ubi-working-container -- yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm
----

[,]
....

<<< OUTPUT ABRIDGED >>>

======================================================================================================================================
 Package                                       Architecture                            Version                                    Repository                                     Size
======================================================================================================================================
Installing:
 epel-release                                  noarch                                  9-2.el9                                    @commandline                                   17 k

Transaction Summary
======================================================================================================================================
Install  1 Package

<<< OUTPUT ABRIDGED >>>

Installed:
  epel-release-9-2.el9.noarch

Complete!
....

From the above output, you can see that the epel-release RPM was installed
successfully inside the container.  You could verify this was not completed
on the host by looking for the RPM on the host system.

[,bash]
----
rpm -q epel-release
----

[,]
....

package epel-release is not installed
....

If your repository configurations are not distributed as an RPM, but instead as
individual `.repo` files, you could use the `buildah copy` command to copy
files from the host operating system into the container image.  You will see
an example of using `buildah copy` later in this lab.
= Installing the target software
:difficulty: basic
:id: s0nj42hpefg0
:slug: step3
:tabs: [{"title"=>"Terminal", "type"=>"terminal", "hostname"=>"rhel"}, {"title"=>"RHEL Web Console", "type"=>"service", "hostname"=>"rhel", "path"=>"/", "port"=>9090}]
:timelimit: 60
:type: challenge

Now that the yum repositories are defined within the container, you can use
another `yum install`, executed within the container, to install the target
software: `moon-buggy`.

[,bash]
----
buildah run ubi-working-container -- yum -y install moon-buggy
----

[,]
....

<<< OUTPUT ABRIDGED>>>

==============================================================================================
 Package        Architecture       Version                 Repository          Size
==============================================================================================
Installing:
 moon-buggy     x86_64             1.0.51-30.el9           epel                79 k

<<< OUTPUT ABRIDGED >>>

Installed:
  alsa-lib-1.2.6.1-3.el9.x86_64     audiofile-1:0.3.6-30.el9.x86_64   esound-libs-1:0.2.41-27.el9.x86_64   flac-libs-1.3.3-9.el9.x86_64   libogg-2:1.3.4-6.el9.x86_64
  moon-buggy-1.0.51-30.el9.x86_64

Complete!
....

From the above output, you can see that `moon-buggy` was successfully installed
into the container.  The `yum` transaction also installed several required
pieces of software as well.
= Committing the new container image
:difficulty: basic
:id: l6d7bdfdpvev
:slug: step4
:tabs: [{"title"=>"Terminal", "type"=>"terminal", "hostname"=>"rhel"}, {"title"=>"RHEL Web Console", "type"=>"service", "hostname"=>"rhel", "path"=>"/", "port"=>9090}]
:timelimit: 60
:type: challenge

At this point, the container is configured.  It is time to transition from a
working container into a committed image.  In the command below, you will use
the `buildah` command to commit the working container to an image called:
`moon-buggy`.

[,bash]
----
buildah commit ubi-working-container moon-buggy
----

[,]
....

Getting image source signatures
Copying blob 226bfaae015f skipped: already exists
Copying blob 70056249a0e2 skipped: already exists
Copying blob b03eece6d0e2 done
Copying config dbb1368db3 done
Writing manifest to image destination
Storing signatures
dbb1368db3f9b5f5cd651581e3c6e0bee242c25ef8ec68d2bef9f18e98f05209
....

The above output shows that the commit was successful, however you can verify
this by looking at the available container images on the system.

[,bash]
----
podman image list
----

[,]
....

REPOSITORY                            TAG      IMAGE ID       CREATED          SIZE
localhost/moon-buggy                  latest   dbb1368db3f9   15 seconds ago   335 MB
registry.access.redhat.com/ubi9/ubi   latest   a1f8c9699786   4 weeks ago      211 MB

<<< OUTPUT ABRIDGED >>>
....

Notice in the output above that `moon-buggy` is the first container image
listed in the `podman image list` output.
= Running the new containerized software
:difficulty: basic
:id: xfniocpityc8
:slug: step5
:tabs: [{"title"=>"Terminal", "type"=>"terminal", "hostname"=>"rhel"}, {"title"=>"RHEL Web Console", "type"=>"service", "hostname"=>"rhel", "path"=>"/", "port"=>9090}]
:timelimit: 60
:type: challenge

Now the software has been installed and a new container image created.  It is
time to spawn a runtime of the container image and validate the software.  The
software we are using is a commandline command.  When you `run` the container,
it will be in interactive (`-it`) mode, based on the `moon-buggy` container
image, and the command run interactively will be `/usr/bin/moon-buggy`.

[,bash]
----
podman run -it moon-buggy /usr/bin/moon-buggy
----

[,]
....

<<< OUTPUT ABRIDGED >>>
               MM     MM   OOOOO    OOOOO   NN     N
               M M   M M  O     O  O     O  N N    N
               M  M M  M  O     O  O     O  N  N   N
               M   M   M  O     O  O     O  N   N  N
               M       M  O     O  O     O  N    N N
               M       M   OOOOO    OOOOO   N     NN

                     BBBBBB   U     U   GGGGG    GGGGG   Y     Y
                     B     B  U     U  G     G  G     G   Y   Y
                     BBBBBB   U     U  G        G          Y Y
                     B     B  U     U  G   GGG  G   GGG     Y
                     B     B  U     U  G     G  G     G    Y
                     BBBBBB    UUUUU    GGGGG    GGGGG   YY

<<< OUTPUT ABRIDGED >>>
....

You can now play the Moon Buggy game, which is a text-based version of the
popular Moon Patrol.  When you are finished, use the `q` command to quit the
game, which will terminate the container.

Alternatively you can use `podman` to kill the running container from
*Terminal 2*.

[,bash]
----
podman kill $(podman ps | grep -v CONTAINER | cut -f1 -d" " )
----
